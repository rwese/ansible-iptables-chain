#!/usr/bin/env bash
set -x
# ANSIBLE GENERATED, DO NOT MODIFY!!!!!

# delete the existing chain
# these are allowed to fail
iptables -D INPUT -i {{ iptables_chain__interface }} -j {{ iptables_chain__name }} || true
iptables -X {{ iptables_chain__name }} || true

# create fresh chain
iptables -N {{ iptables_chain__name }}

# already validated can return
iptables -A {{ iptables_chain__name }} -m conntrack ! --ctstate NEW -j  RETURN

{% for cidr in whitelisted_cidrs  %}
iptables -A {{ iptables_chain__name }} -s {{ cidr }}  -j  RETURN
{% endfor %}

# set default to accept during apply
# we use return as we do not want to interfere with other blocking rules by accepting too early

{% for rule in rules  %}
{% set rule_action = iptables_chain__default_match_action %}
{% if rule.action is defined %}
{% set rule_action = rule.action %}
{% endif %}
iptables -A {{ iptables_chain__name }} -p {{ rule.protocol }} --dport {{ rule.port }} -j {{ rule_action }}
{% endfor %}

{% if not iptables_chain__dry_run | bool %}
{% if iptables_chain__log_dropped | bool %}
iptables -A {{ iptables_chain__name }} -j LOG --log-prefix '** DROPPING **'
{% endif %}

# set chain to drop by default
iptables -A {{ iptables_chain__name }} -j {{ iptables_chain__default_no_match_action }}
{% else %}
# dry run, not dropping anything
iptables -A {{ iptables_chain__name }} -j LOG --log-prefix '** DRY-RUN **'
{% endif %}

# add filter to first position of input chain
iptables -I INPUT {{ iptables_chain__rulenum }} -i {{ iptables_chain__interface }} -j {{ iptables_chain__name }}

